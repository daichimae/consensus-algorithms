#!/usr/bin/python3
"""
graphs.py

This program takes a block log file generated by client.py and plots graphs of
the block generation intervals with respect to the block heights, the
cumulative distribution of the block generation intervals for each target and
the target values with respect to the block heights.

Usage: ./graphs.py file_path

Author: Daichi Mae
"""

import sys
import matplotlib.pyplot as plt
import numpy as np
from pylab import *
from scipy.interpolate import spline

output_directory = ""

def plot_intervals(heights, timestamps):
    """
    Plot a graph of block generation intervals with respect to block heights.

    :param heights (list): block heights
    :param timestamps (list): corresponding timestamps in seconds
    """
    intervals = [0]

    # Calculate intervals in minutes
    for i in range(1, len(timestamps)):
        intervals.append((timestamps[i] - timestamps[i-1]) / 60)

    # Plot and export the graph to a png file.
    plt.plot(heights[:-1], intervals[:-1], '.')
    plt.suptitle("Block Generation Intervals")
    plt.xlabel("Block Heights")
    plt.ylabel("Block Generation Intervals (minutes)")
    plt.savefig(output_directory + "intervals.png", bbox_inches="tight")
    plt.clf()

def plot_cdf(heights, timestamps, targets):
    """
    Plot the cumulative distribution of block generation intervals for each
    target.

    :param heights (list): block heights
    :param timestamps (list): corresponding timestamps in seconds
    :param targets (list): corresponding target values
    """
    intervals = []

    # Calculate block generation intervals.
    for i in range(1, len(timestamps)):
        intervals.append(timestamps[i] - timestamps[i-1])
    intervals = intervals[1:]
    
    lower = 0
    upper = 0
    for i in range(1, len(targets)):
        # Group the intervals with the same targets.
        if targets[i-1] == targets[i] and i != len(targets) - 1:
            upper = i
        else:
            # Convert the target into a hex string.
            target_hex = hex(int(targets[i-1]))[2:].upper()
            target_hex = "0x" + ((64 - len(target_hex)) * "0") + target_hex

            # If there is an interval greater than 60 seconds show the
            # intervals in minutes otherwise in seconds.
            selected_intervals = intervals[lower:upper]
            if max(selected_intervals) > 60:
                selected_intervals = list(map(
                    lambda x: x/60 ,selected_intervals))
                unit = "minutes"
            else:
                unit = "seconds"

            # Calculate P(X <= x).
            number_of_bins = 20
            counts, bin_edges = np.histogram(
                selected_intervals, bins=number_of_bins, normed=True)
            cdf = np.cumsum(counts)
            x = bin_edges[1:]
            y = cdf/cdf[-1]
            x_smooth = np.linspace(np.array(x).min(), np.array(x).max(), 200)
            y_smooth = spline(x, y, x_smooth)

            # Plot and export the graph to a png file.
            plt.plot(x_smooth, y_smooth)
            plt.suptitle("Cumulative Distribution of Block Generation Intervals")
            plt.title("Target: " + target_hex, fontsize=8.5)
            plt.xlabel("Block Generation Intervals ({0})".format(unit))
            plt.ylabel("P(X <= x)")
            plt.savefig(output_directory + "cdf{0}.png".format(lower),
                        bbox_inches="tight")
            plt.clf()
            lower = i

def plot_targets(heights, targets):
    """
    Plot a graph of target values with respect to block heights.
    
    :param heights (list): block heights
    :param targets (list): corresponding target values
    """
    plt.plot(heights, targets)
    plt.suptitle("Target Transition")
    plt.xlabel("Block Heights")
    plt.ylabel("Targets")
    plt.savefig(output_directory + "targets.png", bbox_inches="tight")
    plt.clf()
    
def main():
    """
    Read a file and plot graphs.
    """
    if len(sys.argv) <= 1:
        print("Provide a file name.")
    else:
        # Save graphs in the same directory as the log file.
        global output_directory
        if sys.argv[1].find('/') != -1:
            output_directory = sys.argv[1].rsplit('/', 1)[0]
            if output_directory == ".":
                output_directory = ""
            elif output_directory != "" and output_directory != ".":
                output_directory = output_directory + "/"
        
        heights = []
        timestamps = [] # in seconds
        targets = []
        with open(sys.argv[1]) as file:
            for line in file:
                height, timestamp, target = line.split(',')
                heights.append(int(height))
                timestamps.append(float(timestamp) / 1000)
                targets.append(int(target))

        plot_intervals(heights, timestamps)
        plot_cdf(heights, timestamps, targets)
        plot_targets(heights, targets)
        
if __name__ == "__main__":
    main()
